# src/core/DataManager.py

import os
import json
import logging
from copy import deepcopy
from typing import Any, Dict, List, Optional

class DataManager:
    """
    Manages data storage and retrieval across pipeline steps.
    """
    def __init__(self, base_save_folder: str, final_output_folder: str):
        """
        Initialize the DataManager with directories for saving data.

        :param base_save_folder: Path to save intermediate results
        :param final_output_folder: Path to save final results
        """
        self.base_save_folder = base_save_folder
        self.final_output_folder = final_output_folder
        self.current_data_folder = None
        os.makedirs(self.base_save_folder, exist_ok=True)
        logging.info(f"DataManager initialized with base_save_folder: {self.base_save_folder}, final_output_folder: {self.final_output_folder}")

    def update_data(self, step_name: str, data: Any) -> str:
        """
        Update current data and save intermediate results.

        :param step_name: Name of the current step
        :param data: Data generated by the current step
        :return: Path to the saved data file
        """
        step_folder = os.path.join(self.base_save_folder, step_name)
        self.current_data_folder = step_folder

        os.makedirs(step_folder, exist_ok=True)
        return self._save_jsonl(step_folder, 'result.jsonl', data)

    def _save_jsonl(self, folder: str, filename: str, data: List[Dict]) -> str:
        """
        Save data as a JSONL file. 

        :param folder: Directory to save the file
        :param filename: Name of the JSONL file
        :param data: List of dictionaries to save
        :return: Path to the saved JSONL file
        """
        file_path = os.path.join(folder, filename)
        with open(file_path, 'w') as f:
            for item in data:
                f.write(json.dumps(item) + '\n')
        logging.info(f"Saved {len(data)} items to {file_path}")
        return file_path

    def save_final_results(self):
        """
        Save final results to the specified final output folder.

        Moves the current data folder to the final output folder.
        """
        if not self.current_data_folder:
            logging.error("No current data folder to save as final results.")
            raise ValueError("current_data_folder is not set.")
        
        try:
            if os.path.exists(self.final_output_folder):
                logging.warning(
                    f"Final output folder {self.final_output_folder} already exists. It will be overwritten."
                )
                os.replace(self.final_output_folder, self.final_output_folder + "_backup")
            os.rename(self.current_data_folder, self.final_output_folder)
            logging.info(f"Final results saved to {self.final_output_folder}")
        except Exception as e:
            logging.error(f"Failed to save final results: {e}")
            raise

    def get_path(self, step_name: str) -> str:
        """
        Get the path to the saved data for a specific step.

        :param step_name: Name of the step
        :return: Path to the step's data folder
        """
        return os.path.join(self.base_save_folder, step_name)

    def get_current_data(self) -> Optional[str]:
        """
        Get the path to the current data folder.

        :return: Path to the current data folder
        """
        return self.current_data_folder

class Recorder:
    """
    Records and manages data for each step in the pipeline.
    """
    def __init__(self, data_manager: DataManager, step_name: str):
        """
        Initialize the Recorder with a DataManager and step name.

        :param data_manager: Instance of DataManager
        :param step_name: Name of the current step
        """
        self.data_manager = data_manager
        self.step_name = step_name
        self.captions = []

    def record(self, batch_data: List[Dict]):
        """
        Record a batch of data.

        :param batch_data: List of dictionaries representing data items
        """
        self.captions.extend(batch_data)

    def dump(self) -> str:
        """
        Save the recorded data using the DataManager.

        :return: Path to the saved data file
        """
        logging.info(f"Recording data for step {self.step_name}")
        return self.data_manager.update_data(
                step_name=self.step_name,
                data=self.captions,
        )